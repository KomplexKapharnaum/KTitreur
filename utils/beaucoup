#!/usr/bin/env python3
import random
import curses
import os.path
import threading
import time
import socket

BROADCAST = '2.0.255.255'
TITREURS = ['2.0.11.44', '2.0.11.45', '2.0.11.48', '2.0.11.50', '2.0.11.51', '2.0.11.52']
IP = TITREURS.copy()
PORT = 3742
EVENT = threading.Event()
CONSOLE = []
CURRENTPL = {}
for d in TITREURS:
    CURRENTPL[d] = []


class FuncThread(threading.Thread):
    def __init__(self, target, window):
        threading.Thread.__init__(self)
        self._target = target
        self._window = window
        self._scene = 0

    def scene(self, num):
        self._scene = num
        self.start()

    def run(self):
        self._target(self._window, self._scene)

    def stop(self):
        if self.isAlive():
            global EVENT
            EVENT.set()
            self.join()
        EVENT.clear()


def play_scenario(win, num):
    path = 'scenario-'+str(num)+'.txt'

    scene_win(win, str(num))

    if not os.path.exists(path):
        win.addstr("\n ERROR: File "+path+" not found")
        return False

    with open(path) as f:
        content = f.readlines()
    content = [x.strip() for x in content]   # remove \n


    # win.addstr("\n Playing "+path+"\n")
    while run_content(win, content):
        scene_win(win, str(num))

    global EVENT
    if EVENT.is_set():
        win.addstr("\n\n Stopped.")
        return False

    win.addstr("\n\n Done.")
    return True


def run_content(win, content):
    global EVENT

    for line in content:
        if EVENT.is_set():
            return False

        line = line.strip()
        if line.startswith('#loop'): return True
        elif line.startswith('#quit'): return False
        else: execute_cmd(win, line)

    return False


def execute_cmd(win, line):
    global IP, PORT, EVENT, TITREURS

    # PARSING META
    if line.startswith('#'):
        data = line.split(' ')

        if data[0] == "#ip":
            if len(data) > 1:
                IP = data[1:]
                win.addstr("\n #ip: "+str(IP))
        elif data[0] == "#to":
            if len(data) > 1:
                IP = []
                for to in data[1:]:
                    if to == 'all': IP =  TITREURS.copy()
                    else: IP.append('2.0.11.'+str(int(to)))
                win.addstr("\n #to: "+str(IP))
        elif data[0] == "#port":
            if len(data) > 1:
                PORT = int(data[1])
                win.addstr("\n #port: "+str(PORT))
        elif data[0] == "#waitms":
            if len(data) > 1:
                win.addstr("\n #wait for: "+str(int(data[1])/1000.0)+"s")
                EVENT.wait(timeout=int(data[1])/1000.0)
        elif data[0] == "#wait":
            if len(data) > 1:
                time = int(float(data[1])*1000)
                if len(data) > 2:
                    time2 = int(float(data[2])*1000)
                    time = random.randint(time,time2)
                win.addstr("\n #wait for: "+str(time/1000.0)+"s")
                EVENT.wait(timeout=time/1000.0)
        elif data[0] == "#quit":
            win.addstr("\n #quit")
            return False
        elif data[0] == "#loop":
            win.addstr("\n #loop")
            return True
        elif data[0] == "#clearscreen":
            win.clear()

    # SENDING COMMANDS
    elif line != '':
        global CURRENTPL
        send(line)
        win.addstr("\n sent: "+line)

        # STORE PL
        if line == 'clear':
            for d in IP: CURRENTPL[d] = []
        elif line.startswith('text'):
            for d in IP: CURRENTPL[d] = [(' ').join(line.split(' ')[2:])]
        elif line.startswith('add'):
            for d in IP: CURRENTPL[d].append((' ').join(line.split(' ')[2:]))

    CONSOLE.append(line)


def send(line):
    global IP, PORT
    for ip in IP:
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        if ip.endswith('255'):
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        sock.sendto(line.encode('utf-8'), (ip, PORT))


def sendtoall(line):
    global BROADCAST, PORT
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    sock.sendto(line.encode('utf-8'), (BROADCAST, PORT))


def header_win(win):
    global TITREURS, IP
    win.clear()
    win.addstr("\n BEAUCOUP BEAUCOUP \n", curses.A_STANDOUT)
    win.addstr("  Selected devices: ")
    for k, d in enumerate(TITREURS):
        mode = curses.A_STANDOUT if d in IP  else curses.A_BOLD
        win.addstr(" ")
        win.addstr(" "+str(k+1)+" ", mode)
    win.addstr("\n\n\n")

def console_win(win):
    global CONSOLE
    win.addstr("\n\n CONSOLE \n", curses.A_STANDOUT)
    win.addstr("  "+("\n  ").join(CONSOLE))
    win.addstr("\n\n")


def home_win(win):
    header_win(win)
    win.addstr(" HOME \n", curses.A_STANDOUT)
    win.addstr("\t0-9 for FX scenario \n\tINSER for playlist \n\tPAGEUP for freetext \n\tSUPPR to clear selected \n\tFIN to clearall \n\th for help \n\tESC to quit ")
    # console_win(win)

def manu_win(win, txt):
    header_win(win)
    win.addstr(" FREETEXT \n", curses.A_STANDOUT)
    win.addstr("  Live typing - '/' second line of text\n\n")
    win.addstr("  "+txt.replace('/','\n  '))
    console_win(win)

def playlist_win(win, txt):
    global CURRENTPL
    header_win(win)
    win.addstr(" PLAYLIST \n", curses.A_STANDOUT)
    for k, d in enumerate(TITREURS):
        mode = curses.A_STANDOUT if d in IP  else curses.A_BOLD
        win.addstr(" "+str(k+1)+" ", mode)
        win.addstr("  "+(' | ').join(CURRENTPL[d]))
        win.addstr("\n")

    win.addstr("\n\n")
    win.addstr(" ADD TEXT \n", curses.A_STANDOUT)
    win.addstr("   "+txt.replace('/','\n    '))
    win.addstr("\n")
    console_win(win)

def scene_win(win, num):
    header_win(win)
    win.addstr(" FX Scene: "+str(num)+" \n", curses.A_STANDOUT)
    console_win(win)


def main(win):
    global IP, BROADCAST, TITREURS

    scenarioThread = FuncThread(play_scenario, win)
    win.nodelay(True)
    curses.resizeterm(50,100)
    page = 'home'
    home_win(win)
    freetxt = ''
    playtxt = ''

    while 1:
        # try:
            key = win.getch()

            #
            # PAGE SELECT
            #
            if key == 262:  # HOME
                page = 'home'
                scenarioThread.stop()
                home_win(win)

            #PLAYLIST
            elif key == 331: # INSER
                page = 'playlist'
                playtxt = ''
                scenarioThread.stop()
                IP = []
                playlist_win(win, playtxt)
                continue

            # FREETEXT
            elif key == 339: # PAGEUP
                page = 'manu'
                scenarioThread.stop()
                freetxt = ''
                IP = TITREURS.copy()
                manu_win(win, freetxt)
                continue

            # SCENE FX
            elif (page == 'home' or page == 'scene') and (key >= 48 and key <= 57):
                page = 'scene'
                scenarioThread.stop()
                scenarioThread = FuncThread(play_scenario, win)
                scenarioThread.scene(key-48)

            # CLEARALL
            elif key == 360: # END
                sendtoall('clear')

            # CLEARSELECTED
            elif key == 330: # SUPPR
                execute_cmd(win, 'clear')


            # DEVICE SELECTOR
            elif key >= 265 and key <= 276:
                if key == 276: # F12
                    if len(IP) > 0: IP = []
                    else: IP = TITREURS.copy()
                else: # F1 -> F11
                    sel = key-265
                    if sel < len(TITREURS):
                        if TITREURS[sel] in IP: IP.remove(TITREURS[sel])
                        else: IP.append(TITREURS[sel])



            #
            # HOME SPECIFIC
            #
            if page == 'home':

                home_win(win)

                # QUIT
                if key == 27:
                    break

                # HELP
                if key == ord('h'):
                    win.clear()
                    win.addstr("\n BEAUCOUP help: \n", curses.A_STANDOUT)
                    win.addstr("\n   Destination: \n", curses.A_BOLD)
                    win.addstr("      #to all            = broadcast \n")
                    win.addstr("      #to 45 53 54       = send to titreur 45, 53 and 54 \n")
                    win.addstr("      #ip 2.0.11.50      = send to 2.0.11.50 \n")
                    win.addstr("      #port 3742         = change port (default 3742) \n")

                    win.addstr("\n   Scenario: \n", curses.A_BOLD)
                    win.addstr("      #wait 1.5          = pause for 1.5 s \n")
                    win.addstr("      #waitms 1000       = pause for 1000 ms \n")
                    win.addstr("      #loop              = restart from beggining \n")
                    win.addstr("      #quit              = exit scenario \n")

                    win.addstr("\n   Display text: \n", curses.A_BOLD)
                    win.addstr("      text MODE blablba       = display \"blablba\" using MODE \n")
                    win.addstr("      text MODE line1/line2   = display \"line1\" and \"line2\" using MODE \n")
                    win.addstr("         Available Modes:\n")
                    win.addstr("           NO_SCROLL_NORMAL\n")
                    win.addstr("           SCROLL_NORMAL\n")
                    win.addstr("           SCROLL_LOOP_NORMAL\n")
                    win.addstr("           NO_SCROLL_BIG\n")
                    win.addstr("           SCROLL_BIG\n")
                    win.addstr("           SCROLL_LOOP_BIG\n")

                    win.addstr("\n   Random playlist: \n", curses.A_BOLD)
                    win.addstr("      clear              = empty playlist \n")
                    win.addstr("      add MODE blabla    = add \"blabla\" with MODE to playlist \n")
                    win.addstr("      speed 1000         = playlist next item in ms \n")
                    win.addstr("      speed 1000 2000    = playlist next item in ms, random \n")

                    win.addstr("\n   Misc: \n", curses.A_BOLD)
                    win.addstr("      scroll 50          = scroll speed \n")


            #
            # PLAYLIST
            #
            if page == 'playlist':

                # CHAR
                if key >= 32 and key <= 168:
                    playtxt += chr(key)
                # BACKSPACE
                elif key == 263:
                    playtxt = playtxt[:-1]
                # ENTER = add
                elif key == 10:
                    if playtxt.startswith('scroll') or playtxt.startswith('speed'):
                        cmd = playtxt
                    elif '/' in playtxt:
                        if len(playtxt.split('/')[1]) < 9: cmd = 'add NO_SCROLL_NORMAL '+playtxt
                        else: cmd = 'add SCROLL_LOOP_NORMAL '+playtxt
                    else:
                        if len(playtxt) < 9: cmd = 'add NO_SCROLL_BIG '+playtxt
                        else: cmd = 'add SCROLL_LOOP_BIG '+playtxt
                    execute_cmd(win, cmd)
                    playtxt = ''

                playlist_win(win, playtxt)





            #
            # MANU
            #
            if page == 'manu':

                cFt = freetxt
                # CHAR
                if key >= 32 and key <= 168:
                    freetxt += chr(key)
                # BACKSPACE
                elif key == 263:
                    freetxt = freetxt[:-1]
                # ENTER = clear
                elif key == 10:
                    freetxt = ''

                if cFt != freetxt:
                    if '/' in freetxt:
                        if len(freetxt.split('/')[1]) < 9: cmd = 'text NO_SCROLL_NORMAL '+freetxt
                        else: cmd = 'text SCROLL_LOOP_NORMAL '+freetxt
                    else:
                        if len(freetxt) < 9: cmd = 'text NO_SCROLL_BIG '+freetxt
                        else: cmd = 'text SCROLL_LOOP_BIG '+freetxt
                    execute_cmd(win, cmd)

                manu_win(win, freetxt)


            if key == -1: time.sleep(0.1)
            else: win.addstr("\n\n"+str(key))




        # except Exception as e:
        #    # No input
        #    pass

curses.wrapper(main)
